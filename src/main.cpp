#include <fstream>
#include <iostream>
#include <Evaluator.hpp>

#include "Lexer.hpp"
#include "Parser.hpp"

struct Arguments final
{
    Arguments(const int argc, char** argv)
    {
        for (auto i = 1; i < argc; ++i) {
            const std::string_view arg = argv[i];

            if (arg == "-a" || arg == "--all") {
                showTokens = true;
                showSyntaxTree = true;
                showGeneratedByteCode = true;
                showExecutionProcess = true;
            }
            else if (arg == "-l" || arg == "--lexer") {
                showTokens = true;
            }
            else if (arg == "-t" || arg == "--tree") {
                showSyntaxTree = true;
            }
            else if (arg == "-b" || arg == "--bytecode") {
                showGeneratedByteCode = true;
            }
            else if (arg == "-p" || arg == "--process") {
                showExecutionProcess = true;
            }
            else if (arg == "-h") {
                showHelpMessage = true;
            }
            else if (i == 1) {
                filename = arg;
            }
            else {
                showHelpMessage = true;
            }
        }
    }

    std::string filename = "";
    bool showTokens = false;
    bool showSyntaxTree = false;
    bool showGeneratedByteCode = false;
    bool showExecutionProcess = false;
    bool showHelpMessage = false;
};

void printHelp(int argc, char** argv)
{
    std::cout <<
        "USL - useless scripting language.\n\n"
        "Usage:\n"
        "\t"	"usl [<file>] [option]...\n\n"
        "Options:\n"
        "\t"	"-a, --all\tShow all debug information\n"
        "\t"	"-l, --lexer\tShow lexer output\n"
        "\t"	"-t, --tree\tShow abstract syntax tree\n"
        "\t"	"-b, --bytecode\tShow generated bytecode\n"
        "\t"	"-p, --process\tShow execution process\n"
        "\t"	"-h, --help\tShow this message\n";
}

int main(const int argc, char** argv)
{
    // Handle console arguments
    const Arguments arguments(argc, argv);

    if (arguments.showHelpMessage || argc <= 1) {
        printHelp(argc, argv);
        return 0;
    }

    std::ifstream file(arguments.filename);
    if (!file.is_open()) {
        std::cerr << "Unable to open file: " << arguments.filename << std::endl;
        return 1;
    }

    // Read program text
    std::string text;

    file.seekg(0, std::ios::end);
    text.reserve(file.tellg());
    file.seekg(0, std::ios::beg);

    text.assign(
        std::istreambuf_iterator<char>(file),
        std::istreambuf_iterator<char>());

    try {
        // Generate tokens
        app::Lexer lexer;
        const auto& tokens = lexer.run(text);

        if (arguments.showTokens) {
            printf("Lexer output: \n");
            for (const auto& token : tokens) {
                printf("(%2zu) %s\n", token.first, std::string{ token.second }.c_str());
            }
        }

        // Parse tokens
        app::Parser parser{ arguments.showSyntaxTree };
        const auto& byteCode = parser.parse(tokens);

        if (arguments.showGeneratedByteCode) {
            printf("Generated bytecode: \n");
            for (size_t i = 0; i < byteCode.size(); ++i) {
                printf("[%3zu] ", i);
                print(byteCode[i]);
                printf("\n");
            }
        }

        // Evaluate
        app::Evaluator evaluator{ arguments.showExecutionProcess };
        evaluator.eval(byteCode);
    }
    catch (const std::runtime_error & e) {
        std::cout << "ERR: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
